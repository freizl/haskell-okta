{-# LANGUAGE OverloadedStrings #-}

module Okta.Samples.Scotty.Handlers where

import           Control.Applicative
import           Control.Lens                 ((^.))
import           Control.Monad
import           Control.Monad.Except
import           Control.Monad.IO.Class       (liftIO)
import           Data.Aeson                   (encode)
import qualified Data.ByteString.Lazy.Char8   as BS
import           Data.Text.Lazy               (Text)
import qualified Data.Text.Lazy               as T
import           Network.HTTP.Types
import           Prelude                      hiding (exp)

import           Data.Maybe
import           Web.Scotty
import           Web.Scotty.Internal.Types

import           Okta.Samples.Common.OIDC
import           Okta.Samples.Common.Token
import           Okta.Samples.Common.Types
import           Okta.Samples.Scotty.Sessions
import           Okta.Samples.Scotty.Utils
import           Okta.Samples.Scotty.Views

redirectToProfileM :: ActionM ()
redirectToProfileM = redirect "/profile"

redirectToHomeM :: ActionM ()
redirectToHomeM = redirect "/"

errorM :: Text -> ActionM ()
errorM = throwError . ActionError

globalErrorHandler :: Text -> ActionM ()
globalErrorHandler t = status status401 >> errorTpl t

homeH :: ActionM ()
homeH = getCookieUserM >>= homeTpl

loginCustomH :: Config -> ActionM ()
loginCustomH c = withCookieUserM (const redirectToProfileM) (loginCustomTpl c)

loginRedirectH :: Config -> OpenIDConfiguration -> ActionM ()
loginRedirectH c oc = withCookieUserM (const redirectToProfileM) (loginToOkta c oc generatedState generatedNonce)

generatedState :: Text
generatedState = "okta-hosted-login-state-xyz"

generatedNonce :: Text
generatedNonce = "okta-hosted-login-nonce-123"

loginToOkta :: Config -> OpenIDConfiguration -> Text -> Text -> ActionM ()
loginToOkta c openidConfig astate anonce =
  let oc = c ^. oidc
      concatParam (a, b) = T.intercalate "=" [a, b]
      queryStr = T.intercalate "&" $ map concatParam [ ("client_id", oc ^. oidcClientId)
                                    , ("response_type", "code")
                                    , ("response_mode", "query")
                                    , ("scope", oc ^. oidcScope)
                                    , ("redirect_uri", oc ^. oidcRedirectUri)
                                    , ("state", astate)
                                    , ("nonce", anonce)
                                    ]
      fullurl = T.concat [ openidConfig ^. authorizationEndpoint
                          , "?"
                          , queryStr
                          ]
  in
    redirect fullurl


profileH :: Config -> ActionM ()
profileH _ = withCookieUserM profileTpl redirectToHomeM

logoutH :: ActionM ()
logoutH = deleteWidgetCookieM >> deleteCookieUserM >> redirectToHomeM

callbackH :: Config -> OpenIDConfiguration -> ActionM ()
callbackH c oc = do
  -- params from cookie which is generated by okta-signin-widget
  stateC <- getCookiesM "okta-oauth-state"
  nonceC <- getCookiesM "okta-oauth-nonce"
  authorizeCallbackH c oc (stateC <|> Just generatedState) (nonceC <|> Just generatedNonce)

authorizeCallbackH :: Config
          -> OpenIDConfiguration
          -> Maybe Text -- ^ state
          -> Maybe Text -- ^ nonce
          -> ActionM ()
authorizeCallbackH c openidConfig astate anonce= do
  let stateC = maybeToList astate
  let nonceC = maybeToList anonce

  -- params from callback request query
  pas <- params
  let codeP = paramValue "code" pas
  let stateP = paramValue "state" pas
  let errorP = paramValue "error" pas
  let errorDescP = paramValue "error_description" pas

  -- validation failure hence error flow
  unless (null errorP) (errorM $ T.unwords $ errorP ++ [":"] ++ errorDescP)
  when (null codeP) (errorM "no code found from callback request")
  when (null stateP) (errorM "no state found from callback request")
  when (null nonceC) (errorM "no nonce found in the cookie")
  when (null stateC) (errorM "no state found in the cookie")
  when (stateP /= stateC) (errorM $ T.unwords $
                           ["state is not match. state from parameter is:" ]
                           ++ stateP
                           ++ [ ". state from cookie is:" ]
                           ++ stateC
                          )
  -- successful flow
  handleAuthCallback c openidConfig codeP nonceC


handleAuthCallback :: Config -> OpenIDConfiguration -> [Text] -> [Text] -> ActionM ()
handleAuthCallback c openidConfig codeP nonceC = do
  r' <- liftIO $ runExceptT $ fetchAuthUser c openidConfig (head codeP) (head nonceC)
  case r' of
    Right userAndClaims -> setCookieUserM (BS.toStrict $ encode userAndClaims) >> redirectToProfileM
    Left e -> errorM e
